# BioSNICAR_GO_PY

Python implementation of BioSNICAR_GO, designed to predict the spectral and broadband albedo and energy absorption in snow and ice with variable grain sizes and densities either clean or with both inorganic and biological particles.

# Current Development status

24 Oct 2019: Snicar_mie and Snicar_GO both fully functional and unit tested against benchmark spectral albedo generated by the Matlab version. This code is therefore very likely consistent with the Matlab version. Further testing (i.e. for consistency between other variables than spectral albedo) will be carried out before tagging a release.

NOTE: CURRENTLY MISSING DATA NEEDED FOR BIO OPTICAL, ICE OPTICAL MODELS
NOTE: CURRENTLY ALL PATHS IN_SCRIPTS STILL POINT TO ORIGINAL BIOSNICAR REPO: UPDATE!

# Background

This is a Python implementation of the BioSNICAR model offering the user a choice between determining ice optical properties using Mie scattering (good for fine snow grains that can be assumed spherical) or geometric optics (good for wet snow and ice). This also enables different grain shapes to be used - geometric optics for hexagonal plates and columns, Mie scattering for spheres. This builds upon legacy FORTRAN and Matlab code developed by Flanner et al. (2007) and Cook et al. (2017, 2019).

The model is a two stream radiative transfer model that predicts the albedo of a snow or ice column with user-defined grain size and density and mass mixing ratios of a range of biological and non-biological particles. In GO mode, the optical properties of the ice grains themselves are calculated using a parameterisation of geometric optics calculations described by van Diedenhoven (2014) and the refractive indices are from Warren and Brandt (2008). In Mie mode the ice optical properties are calculated using Mie scatering codes using the same ice refractive indices. The rationale behind providing GO functionality is that geometric optics enables ice grains shaped as aritrarily large hexagonal plates and columns to be simulated, whereas Mie scattering applies to small spheres. The geometric optics approach is therefore better suited to wet snow or glacier ice, whereas Mie scattering is better for dry snow.

BioSNICAR_GO also offers the option to incorporate algae as a light absorbing impurity, importantly either in the form of snow algae modelled using mie theory, or glacier algae modelled as large (10s - 100s microns), long chains of cells approximated as cylinders after Lee and Pilon, 2013) modelled using geometrical optics. 

The single scattering optical properties of the algae is determine dby a separate Bio-optical model also provided here. Depending whether the user provides a MAC or pigment profile, the bio-optical model returns a cell MAC and imaginary refractive index that is parsed to the Mie or GO solver that in turn calculates the single scattering properties and appends them to a lookup library accessible to the radiative transfer model. The mass absorption coefficients for glacier algae provided in this repository have been determined empirically (Williamson et al. in review).

This functionality, combined with the geometric optics option for the ice matrix makes BioSNICAR_GO applicable to bare glacier ice surfaces as well as wet and dry snowpacks - a significant step forwards from the original BiOSNICAR model published in Cook et al (2017). The model currently includes options for 2 glacier algae of different user-defined dimensions and one snow algae.

# Model Structure
<img src="./Assets/model_structure.jpg" width=1500>


# Environment/Dependencies

It is recommended to run this code in a fresh environment as follows:

```
conda create -n BioSNICAR_py python 3.6.8, numpy, scipy, matplotlib, pandas
conda install xarray dask netCDF4 bottleneck

```

or alternatively create from the yaml file provided in this repository (which also includes packages such as jupyter for running interactively in vscode).

```
conda env create -f BioSNICAR_py.yaml

```

# In this repo

## Files

snicar8d_mie.py: main snicar function using mie optical properties
SNICAR_driver.py: driver script for BioSNICAR_GO package
snicar_mie_tests.py: script for running unit tests against matlab version
BioSNICAR_py.yaml: exported environment
Files in /UnitTests/SnicarX/ are all benchmark spectral albedos for unit testing as predicted by the Matlab version of SNICAR.

## Data
In this repo netCDF files are provided for hexagonal ice grains between 1000 - 20000 microns in both side-length and depth, at 500 - 1000 micron resolution, or small spherical grains between 100 - 3000 microns. Therefore, BioSNICAR_GO can be used to simulate any ice grains with dimensions in that range. The relevant files for any other ice grain dimensions can be added to the working directory by running the geometric optics or Mie scattering scripts provided here. We also provide an optical property library for glacier algae of a range of dimensions. Data is also provided for a packaging effect correction applied to the empirical MAC, our MAC values for individual pigments and entire cells.


## Repository Structure
```
BioSNICAR_GO_PY
|
|----- snicar8d_mie.py
|----- SNICAR_driver.py
|----- snicar_mie_tests.py
|----- BioSNICAR_py.yaml
|
|-----BioOptical_Model
|           |
|           |---Algae_GO.py
|           |---BioOptical_Model.py
|
|-----IceOptical_Model
|           |
|           |---Geometric_Optics_Ice.py
|
|
|-----Data
|       |
|       |---Algal_Optical_Props
|       |      |
|       |      |--all algal single scattering props in .nc
|       |
|       |---GO_files
|       |      |
|       |      |--all ice single scattering props in .nc
|       |      |--mineral dust, ash and BC optical props in .nc
|       |
|       |---Mie_files
|              |
|              |--all ice single scattering props in .nc
|              |--mineral dust, ash and BC optical props in .n
|
|
|-----UnitTests
|            |
|            |----Snicar_mie
|            |        |
|            |        |----apprx_albedo.csv
|            |        |----coszen_albedo.csv
|            |        |----delta_albedo.csv
|            |        |----direct_albedo.csv
|            |        |----dz_albedo.csv
|            |        |----R_sfc_albedo.csv
|            |        |----rds_albedo.csv
|            |        |----rho_albedo.csv
|            |
|            |
|            |----Snicar_GO
|                  |
|                  |----apprx_albedo.csv
|                  |----coszen_albedo.csv
|                  |----delta_albedo.csv
|                  |----direct_albedo.csv
|                  |----dz_albedo.csv
|                  |----R_sfc_albedo.csv
|                  |----rds_albedo.csv
|                  |----rho_albedo.csv
|
|-----Assets
|       |
|       |--model_structure.jpg
|

```

# How to use

Open the driver script, enter desired variable values, run!

# Known bugs and gotchas

1) Diffuse + Eddington
The combination of Eddington 2-stream approximation and diffuse incident radiation causes the albedo to go negative at wavelengths > ~1.4 um. Recommend using quadature or hemispheric mean approximations when diffuse
incident radiation is required.

2) SZA limits
The two stream aproximation seems to fall apart at high zenith angles (>~0.57). This is common to all versions of SNICAR and is explained in Toon et al. (1989).

3) Snow algae
While glacier algae MACs have been determined empirically, we have included only a hypothetical snow algae with potentially realistic pigemnt concentrations derived from the literature. A more accurate, empirically-derived set of single scattering optical properties for real snow algae is needed.


# Unit Testing

Unit testing has been carried out by running the newly translated model and comparing the predicted albedo with that predicted by the Matlab version for identical variable values. The Matlab verson of SNICAR is itself benchmarked against the original FORTRAN version that is implemented in CLM and thoroughly tested. The unit testing undertaken here is archived in the foldr wdir/Unit_Tests/. To run the tests, simply run the snicar_mie_tests.py script. The script holds all variable values constant at a set of defaults defined in-script, apart from a single test variable. The test variable is given a set of values to iterate through. For each test case, the identical case was run using the Matlab version and the output stored in an external csv file. For each test condition, the code simply tests whether the Python and Matlab implementation predicts the same value per unit wavelength. The test is passed if all the predicted values agree within 0.0001. There are separate scripts for testing the Mie and Geometrical Optics implementations.

This Python code was developed and run in Python 3.6.8 64-bit downloaded as part of Anaconda 4.7.11 and run on a Linux (Ubuntu 16.04 LTS) OS using VS Code 1.39.2 (and also repeated in PyCharm 2019.2.3). Under those conditions the unit tests return the following:

```

************ UNIT TESTS ***************
***************  MIE ******************
*****************************************

All tests run with default variable values apart from single 
test variable

Values benchmarked against Matlab version, tests pass if Matlab 
and Python versions are equal to within 
1e-4

************************

APPRX = 1 TEST PASSED WITH TOLERANCE 1e-4
APPRX = 2 TEST PASSED WITH TOLERANCE 1e-4
APPRX = 3 TEST PASSED WITH TOLERANCE 1e-4

**************************************************

NB DIRECT TESTS RUN WITH APRX = 2 DUE TO KNOWN BUG WITH EDDINGTON + DIFFUSE

DIRECT = 0 TEST PASSED WITH TOLERANCE 1e-4
DIRECT = 1 TEST PASSED WITH TOLERANCE 1e-4

**************************************************

DELTA = 0 TEST PASSED WITH TOLERANCE 1e-4
DELTA = 1 TEST PASSED WITH TOLERANCE 1e-4

**************************************************

COSZEN = 0.3 TEST PASSED WITH TOLERANCE 1e-4
COSZEN = 0.35 TEST PASSED WITH TOLERANCE 1e-4
COSZEN = 0.4 TEST PASSED WITH TOLERANCE 1e-4
COSZEN = 0.45 TEST PASSED WITH TOLERANCE 1e-4
COSZEN = 0.5 TEST PASSED WITH TOLERANCE 1e-4

 **************************************************

DZ = ARRAY #0 TEST PASSED WITH TOLERANCE 1e-4
DZ = ARRAY #1 TEST PASSED WITH TOLERANCE 1e-4
DZ = ARRAY #2 TEST PASSED WITH TOLERANCE 1e-4
DZ = ARRAY #3 TEST PASSED WITH TOLERANCE 1e-4
DZ = ARRAY #4 TEST PASSED WITH TOLERANCE 1e-4

 **************************************************

R_sfc = 0.2 TEST PASSED WITH TOLERANCE 1e-4
R_sfc = 0.4 TEST PASSED WITH TOLERANCE 1e-4
R_sfc = 0.6 TEST PASSED WITH TOLERANCE 1e-4

 **************************************************

RDS = ARRAY #0 TEST PASSED WITH TOLERANCE 1e-4
RDS = ARRAY #1 TEST PASSED WITH TOLERANCE 1e-4
RDS = ARRAY #2 TEST PASSED WITH TOLERANCE 1e-4
RDS = ARRAY #3 TEST PASSED WITH TOLERANCE 1e-4
RDS = ARRAY #4 TEST FAILED WITH TOLERANCE 1e-4

 **************************************************

RHO = ARRAY #0 TEST PASSED WITH TOLERANCE 1e-4
RHO = ARRAY #1 TEST PASSED WITH TOLERANCE 1e-4
RHO = ARRAY #2 TEST PASSED WITH TOLERANCE 1e-4
RHO = ARRAY #3 TEST PASSED WITH TOLERANCE 1e-4
RHO = ARRAY #4 TEST PASSED WITH TOLERANCE 1e-4

**************************************************
```

```
************ UNIT TESTS ***************
********* Geometric Optics ************
*****************************************

All tests run with default variable values apart from single 
test variable

Values benchmarked against Matlab version, tests pass if Matlab 
and Python versions are equal to within 
1e-4

************************

NB DIRECT TESTS RUN WITH APRX = 2 DUE TO KNOWN BUG WITH EDDINGTON + DIFFUSE

DIRECT = 0 TEST PASSED WITH TOLERANCE 1e-4
DIRECT = 1 TEST PASSED WITH TOLERANCE 1e-4

**************************************************

APPRX = 1 TEST PASSED WITH TOLERANCE 1e-4
APPRX = 2 TEST PASSED WITH TOLERANCE 1e-4
APPRX = 3 TEST PASSED WITH TOLERANCE 1e-4

**************************************************

DELTA = 0 TEST PASSED WITH TOLERANCE 1e-4
DELTA = 1 TEST PASSED WITH TOLERANCE 1e-4

**************************************************

COSZEN = 0.3 TEST PASSED WITH TOLERANCE 1e-4
COSZEN = 0.35 TEST PASSED WITH TOLERANCE 1e-4
COSZEN = 0.4 TEST PASSED WITH TOLERANCE 1e-4
COSZEN = 0.45 TEST PASSED WITH TOLERANCE 1e-4
COSZEN = 0.5 TEST PASSED WITH TOLERANCE 1e-4

**************************************************

DZ = ARRAY #0 TEST PASSED WITH TOLERANCE 1e-4
DZ = ARRAY #1 TEST PASSED WITH TOLERANCE 1e-4
DZ = ARRAY #2 TEST PASSED WITH TOLERANCE 1e-4
DZ = ARRAY #3 TEST PASSED WITH TOLERANCE 1e-4
DZ = ARRAY #4 TEST PASSED WITH TOLERANCE 1e-4

**************************************************

R_sfc = 0.2 TEST PASSED WITH TOLERANCE 1e-4
R_sfc = 0.4 TEST PASSED WITH TOLERANCE 1e-4
R_sfc = 0.6 TEST PASSED WITH TOLERANCE 1e-4

**************************************************

SIDE LENGTH = ARRAY #0 TEST PASSED WITH TOLERANCE 1e-4
SIDE LENGTH = ARRAY #1 TEST PASSED WITH TOLERANCE 1e-4
SIDE LENGTH = ARRAY #2 TEST PASSED WITH TOLERANCE 1e-4
SIDE LENGTH = ARRAY #3 TEST PASSED WITH TOLERANCE 1e-4

**************************************************

DEPTH = ARRAY #0 TEST PASSED WITH TOLERANCE 1e-4
DEPTH = ARRAY #1 TEST PASSED WITH TOLERANCE 1e-4
DEPTH = ARRAY #2 TEST PASSED WITH TOLERANCE 1e-4

**************************************************

RHO = ARRAY #0 TEST PASSED WITH TOLERANCE 1e-4
RHO = ARRAY #1 TEST PASSED WITH TOLERANCE 1e-4
RHO = ARRAY #2 TEST PASSED WITH TOLERANCE 1e-4
RHO = ARRAY #3 TEST PASSED WITH TOLERANCE 1e-4
RHO = ARRAY #4 TEST PASSED WITH TOLERANCE 1e-4

**************************************************

```

It would be sensible to check that the same results are obtained on a new local machine.

# Permissions
This code is in active development and no permissions are granted at this time.


# Citation
A release tag with a doi will be minted when this code has been fully tested, until then I do not recommend using this code.