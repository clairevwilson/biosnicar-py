"""
#####################################################################
################# BioSNICAR_GO DRIVER SCRIPT ########################

This script is used to test the outputs from my Python translation of
the SNICAR-AD code in BioSNICAR_py against outputs from the original 
Matlab code written by Chloe Whicker (UMich). 

Identical driver scripts were used to generate a 4D array of spectral 
albedo values for combinations of layer thicknesses, r_eff and algal
concentration in the upper layer. This script simply defines an error
tolerance, then compares the spectral albedo in the array generated
by the Matlab code to the corresponding spectrum in the Python code.
If the difference between the two spectra is greater than the tolerance
then the test fails, if it is less than or equal to the tolerance, the
test passes. This is repeated for every spectrum and the number of
passes and fails reported to the user.

This script also contains the functions required to open the .mat files
and resave them as .npy files.

######################################################################
######################################################################

"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import numpy as np
import scipy.io as spio


def LUT_matlab_to_numpy(mat_fname):
    
    """
    script takes the original .mat file output by Whicker et al.'s matlab
    version of SNICAR-AD, divides into four separate LUTs (one for each SZA)
    and resaves as .npy files. This should create four identical .npy LUTs 
    as was output by BioSNICAR_py in AD mode. Only needs to be run once to create 
    .npy files, after these files exist this function can be safely ignored
    (users who have downloaded the full repository do not need to generate these
    files as they are provided already in /Unit_Tests/AD_LUTs/)

    params:
    mat_fname: full path to .mat file containing spectra generated by matlab
                reference code
    
    returns: None, but saves .npy files to wdir

    """

    mat_fname = '/home/joe//Code/BioSNICAR_GO_PY/Unit_Tests/LUT_whicker_Nov23.mat'
    mat_contents = sio.loadmat(mat_fname)

    for i in (sorted(mat_contents.keys())):
        
        if i[0:3] !='alb':
            pass
        
        else:
            tempLUT = np.array(mat_contents[i])
            np.save("/home/joe/Code/BioSNICAR_GO_PY/Unit_Tests/AD_LUTs/{}.npy".format(i),tempLUT, allow_pickle=True) 


    return



def compare_spectra(tolerance, path, solzen, test, plot_spectra):
    
    """

    Function compares spectra generated using this Python package against
    benchmark spectra generated using Whicker/Flanner matlab code. Absolute
    error, pass/fail rate and optional plots are generated.

    ##########
    params:
    tolerance: how close do the python spectra need to be to the matlab 
               for the test to be considered successful?
    path: path to directory containing LUTs
    solzen: there are separate LUTs for different solar zenth angles. Valid values are
            45, 53, 60, 67 degrees.
    test: type of test. "CLEAN" compares spectra generated with no LAIs. "DIRTY" includes LAIs.

    #########
    returns:

    errors: list of maximum absolute errors between py and mat spectra


    ##########
    Notes:
    ##########


    LUTs were generated in both Py and Mat versions using the following variable values:

    radii = [[600,600,525],[800,800,525],[1000,1000,525],[1200,1200,525],[1400,1400,525],\
    [1500,1500,525],[2000,2000,525]]

    lyr_dz = [[0.001,0.001,10],[0.001,0.005,10],[0.001,0.01,10],[0.001,0.02,10],[0.001,0.03,10],[0.001,0.04,10],[0.001,0.05,10],[0.001,0.06,10],\
    [0.001,0.08,10],[0.001,0.1,10],[0.001,0.12,10],[0.001,0.14,10],[0.001,0.16,10],[0.001,0.18,10],[0.001,0.2,10],\
        [0.001,0.25,10],[0.001,0.3,10],[0.001,0.4,10]]

    algae = [[0,0,0],[10000,0,0],[20000,0,0],[30000,0,0],[50000,0,0],[75000,0,0],[100000,0,0],[150000,0,0],\
    [175000,0,0],[200000,0,0],[250000,0,0],[300000,0,0]]

    """

    # load matlab and python versions of albedo arrays
    mat = np.load(str(path +'MAT_albedo_{}.npy'.format(solzen)))
    py = np.load(str(path + 'py_albedo_{}.npy'.format(solzen)))
    wavelengths = np.arange(0.2,5,0.01)
    
    # measure length of each dimension
    len_1 = len(mat[:,0,0,0])
    len_2 = len(mat[0,:,0,0])
    len_3 = len(mat[0,0,:,0])

    # set up zeros for counters
    # and empty list for diff values
    passes = 0
    fails = 0
    errors = []

    # Initial data validation
    # (check array shapes are equal)
    if mat[:,0,0,0].shape != py[:,0,0,0].shape:
        if mat[0,:,0,0].shape != py[0,:,0,0].shape:
            if mat[0,0,:,0].shape != py[0,0,:,0].shape:
                raise ValueError("ARRAYS HAVE DIFFERENT SHAPES")

    # loop through values in each dimension ad retrieve spectrum 
    # from mat and py arrays. Compare them and test max difference
    # against tolerance

    # check test type
    if test == "CLEAN":
        len_LAI = 1 # don't loop through LAIs

    elif test == "DIRTY":
        len_LAI = len(py[0,0,:,0]) # loop through LAIs
    
    for i in np.arange(0,len_1, 2):
        for j in np.arange(0,len_2, 2):
            for k in np.arange(0,len_LAI,1):
                
                diff = abs(mat[i,j,k,:] - py[i,j,k,:])

                diff_max = np.mean(diff)

                errors.append(diff_max)
            
                if diff_max < tolerance:
                    passes +=1

                else:
                    fails +=1

                if plot_spectra:
                    plt.plot(wavelengths,mat[i,j,k,:])
                    plt.plot(wavelengths,py[i,j,k,:], marker='x', linestyle='None')
                    plt.xlim(0.35,1.5),plt.ylim(0,1)
                    plt.xlabel("Wavelength (microns)"),plt.ylabel("Albedo")
                    plt.title("Comparison between Python code and benchmark data")
    
    plt.text(1.0,0.8,"x's = python code\nlines = matlab benchmark")
   
    # reporting
    percent_fails = (fails / (passes+fails)) * 100
    percent_passes = (passes / (passes+fails)) * 100

    print("TOTAL NO. OF TESTS = ", passes+fails)
    print("TOLERANCE = ", tolerance)
    print("NUMBER OF PASSES = ", passes, " ({}%)".format(percent_passes))
    print("NUMBER OF FAILS = ", fails, "  ({}%)".format(percent_fails))
    

    return errors
